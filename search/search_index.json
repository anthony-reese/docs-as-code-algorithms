{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Docs-as-Code Algorithms","text":"<p>This site documents popular algorithm patterns using Markdown and MkDocs as part of a docs-as-code approach to technical problem solving.  </p>"},{"location":"#topics-covered","title":"Topics Covered","text":"<ul> <li>\ud83d\udfe6 Two Pointers  </li> <li>\ud83d\udfe8 Sliding Window  </li> <li>\ud83e\uddf5 String Manipulation  </li> <li>\ud83d\uddc2  Stacks  </li> <li>\ud83d\udd22 Dynamic Programming  </li> <li>\ud83c\udf33 Trees  </li> <li>\ud83d\udcca Sorting  </li> <li>\ud83e\udde9 In-place  </li> <li>\ud83e\udea3 Bucket Sort  </li> </ul>"},{"location":"#sample-docs","title":"Sample Docs","text":"\ud83c\udd94 Problem ID \ud83d\udcc4 Title \ud83d\udcda Category 167 Two Sum II - Input Array Is Sorted Two Pointers 151 Reverse Words in a String Two Pointers 234 Palindrome Linked List Two Pointers 143 Reorder List Two Pointers 238 Product of Array Except Self Sliding Window 438 Find All Anagrams in a String Sliding Window 8 String to Integer (atoi) String Manipulation 232 Implement Queue using Stacks Two Stacks 394 Decode String Two Stacks 139 Word Break Dynamic Programming 2327 Number of People Aware of a Secret Dynamic Programming 236 Lowest Common Ancestor of a Binary Tree Tree DFS (Depth First Search) 75 Sort Colors Sorting 347 Top K Frequent Elements Bucket Sort 73 Set Matrix Zeroes In-place 199 Binary Tree Right Side View BFS (Breadth First Search)"},{"location":"bucket-sort/top-k-frequent-elements/","title":"347. Top K Frequent Elements","text":""},{"location":"bucket-sort/top-k-frequent-elements/#problem-statement","title":"Problem Statement","text":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k</code> most frequent elements. You may return the answer in any order.</p>"},{"location":"bucket-sort/top-k-frequent-elements/#approach-bucket-sort","title":"Approach:  Bucket Sort","text":"<p>We use Bucket Sort to distribute the elements of an array into a number of buckets.</p>"},{"location":"bucket-sort/top-k-frequent-elements/#counting-frequencies","title":"Counting Frequencies:","text":"<ul> <li>The hash map <code>freq</code> associates each element in <code>nums</code> with its count.</li> </ul>"},{"location":"bucket-sort/top-k-frequent-elements/#bucket-sort","title":"Bucket Sort:","text":"<ul> <li> <p>Elements with the same frequency are grouped into buckets (e.g., all elements appearing 3 times go into bucket 3).</p> </li> <li> <p>The maximum frequency cannot exceed the size of the array <code>n</code>.</p> </li> </ul>"},{"location":"bucket-sort/top-k-frequent-elements/#retrieve-top-k-elements","title":"Retrieve Top <code>k</code> Elements:","text":"<ul> <li> <p>Start from the bucket with the highest frequency and work downward.</p> </li> <li> <p>Collect elements until <code>k</code> elements are retrieved.</p> </li> </ul> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_map&lt;int, int&gt; freq;\n        for (int num : nums) {\n            freq[num]++;\n        }\n\n        int n = nums.size();\n        vector&lt;vector&lt;int&gt;&gt; buckets(n + 1);\n        for (auto&amp; pair : freq) {\n            int element = pair.first;\n            int count = pair.second;\n            buckets[count].push_back(element);\n        }\n\n        vector&lt;int&gt; result;\n        for (int i = n; i &gt;= 0 &amp;&amp; result.size() &lt; k; --i) {\n            for (int element : buckets[i]) {\n                result.push_back(element);\n                if (result.size() == k) break;\n            }\n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"bucket-sort/top-k-frequent-elements/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity:</p> <ul> <li> <p>Counting frequencies: \ud835\udc42(\ud835\udc5b), where \ud835\udc5b is the size of nums.</p> </li> <li> <p>Bucket traversal: \ud835\udc42(\ud835\udc5b) (each element is processed once).</p> </li> <li> <p>Total: \ud835\udc42(\ud835\udc5b).</p> </li> </ul> </li> <li> <p>Space Complexity: </p> <ul> <li>\ud835\udc42(\ud835\udc5b) for the buckets and frequency map.</li> </ul> </li> </ul>"},{"location":"bucket-sort/top-k-frequent-elements/#conclusion","title":"Conclusion","text":"<p>This implementation efficiently returns the <code>k</code> most frequent elements, in any order.</p>"},{"location":"dynamic-programming/people-aware-of-secret/","title":"2327. Number of People Aware of a Secret","text":""},{"location":"dynamic-programming/people-aware-of-secret/#problem-statement","title":"Problem Statement","text":"<p>On day <code>1</code>, one person discovers a secret.</p> <p>You are given an integer <code>delay</code>, which means that each person will share the secret with a new person every day, starting from <code>delay</code> days after discovering the secret. You are also given an integer <code>forget</code>, which means that each person will forget the secret <code>forget</code> days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.</p> <p>Given an integer n, return the number of people who know the secret at the end of day <code>n</code>. Since the answer may be very large, return it modulo <code>10</code><sup><code>9</code></sup><code>+ 7</code>.</p>"},{"location":"dynamic-programming/people-aware-of-secret/#approach-dynamic-programming","title":"Approach: Dynamic Programming","text":"<p>We use Dynamic Programming (DP) to efficiently track secret sharing.</p>"},{"location":"dynamic-programming/people-aware-of-secret/#dp-array-initialization","title":"DP Array Initialization:","text":"<ul> <li> <p><code>dp[i]</code> stores the number of people who learn the secret on Day <code>i</code>.</p> </li> <li> <p>Initially, <code>dp[1] = 1</code> (since only one person knows the secret on Day 1).</p> </li> </ul>"},{"location":"dynamic-programming/people-aware-of-secret/#simulating-secret-sharing","title":"Simulating Secret Sharing:","text":"<ul> <li> <p>For each day <code>curDay</code>, if people learn the secret on that day, they will:</p> <ul> <li> <p>Start sharing from <code>curDay + delay</code>.</p> </li> <li> <p>Stop sharing by <code>curDay + forget - 1</code>.</p> </li> </ul> </li> <li> <p>Update <code>dp[nextDay]</code> to track newly aware people.</p> </li> </ul>"},{"location":"dynamic-programming/people-aware-of-secret/#final-count-of-aware-people","title":"Final Count of Aware People:","text":"<ul> <li>Sum up all <code>dp[i]</code> values for the last <code>forget</code> days (since others have forgotten).</li> </ul>"},{"location":"dynamic-programming/people-aware-of-secret/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\n    public:\n        int peopleAwareOfSecret(int n, int delay, int forget) {\n            const int MOD = 1e9 + 7;\n\n            vector&lt;int&gt; dp(n + 1, 0);\n            dp[1] = 1;\n\n            for (int curDay = 1; curDay &lt;= n; ++curDay) {\n                if (dp[curDay] &gt; 0) {\n                    for (int nextDay = curDay + delay; nextDay &lt; curDay + forget &amp;&amp; nextDay &lt;= n; ++nextDay) {\n                        dp[nextDay] = (dp[nextDay] + dp[curDay]) % MOD;\n                    }\n                }\n            }\n\n            int result = 0;\n            for (int day = n - forget + 1; day &lt;= n; ++day) {\n                if (day &gt;= 1) {\n                    result = (result + dp[day]) % MOD;\n                }\n            }\n\n            return result;\n        }\n    };\n</code></pre>"},{"location":"dynamic-programming/people-aware-of-secret/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b * forget) - Nested loops update future days.</p> </li> <li> <p>Space Complexity: \ud835\udc42(\ud835\udc5b) - Stores DP array.</p> </li> </ul>"},{"location":"dynamic-programming/people-aware-of-secret/#conclusion","title":"Conclusion","text":"<p>Tracks secret spread and expiration using dynamic programming.</p>"},{"location":"dynamic-programming/word-break/","title":"139. Word Break","text":""},{"location":"dynamic-programming/word-break/#problem-statement","title":"Problem Statement","text":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p> <p>Note that the same word in the dictionary may be reused multiple times in the segmentation.</p>"},{"location":"dynamic-programming/word-break/#approach-dynamic-programming","title":"Approach: Dynamic Programming","text":"<p>We use dynamic programming (DP) to determine whether the string <code>s</code> can be segmented into valid dictionary words.</p>"},{"location":"dynamic-programming/word-break/#dictionary-lookup","title":"Dictionary Lookup:","text":"<ul> <li>To speed up checking if a word exists in <code>wordDict</code>, we use an unordered set (<code>dict</code>) for \ud835\udc42(1) lookups.</li> </ul>"},{"location":"dynamic-programming/word-break/#dynamic-programming","title":"Dynamic Programming:","text":"<ul> <li>The outer loop iterates over the length of <code>s</code> (<code>i</code>), and the inner loop iterates over potential split points (<code>j</code>) in the substring <code>s[0:i]</code>.</li> </ul>"},{"location":"dynamic-programming/word-break/#efficient-substring-matching","title":"Efficient Substring Matching:","text":"<ul> <li>For each <code>i</code> and <code>j</code>, check if <code>s[j:i]</code> is in <code>wordDict</code> and if <code>dp[j]</code> is <code>true</code>.   </li> </ul>"},{"location":"dynamic-programming/word-break/#final-result","title":"Final Result:","text":"<ul> <li>If <code>dp[n]</code> is <code>true</code>, the string <code>s</code> can be segmented; otherwise, the string cannot.</li> </ul>"},{"location":"dynamic-programming/word-break/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        unordered_set&lt;string&gt; dict(wordDict.begin(), wordDict.end());\n        int n = s.size();\n\n        vector&lt;bool&gt; dp(n + 1, false);\n        dp[0] = true;\n\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 0; j &lt; i; j++) {\n                if (dp[j] &amp;&amp; dict.count(s.substr(j, i - j))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[n];\n    }\n};\n</code></pre>"},{"location":"dynamic-programming/word-break/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity:</p> <ul> <li> <p>\ud835\udc42(\ud835\udc5b<sup>2</sup>+\ud835\udc5a), where \ud835\udc5b is the length of <code>s</code> and \ud835\udc5a is the total number of characters in <code>wordDict</code> (building the set).</p> </li> <li> <p>The nested loops result in \ud835\udc42(\ud835\udc5b<sup>2</sup>), and substring lookups and dictionary checks are \ud835\udc42(1) due to the hash set.</p> </li> </ul> </li> <li> <p>Space Complexity: </p> <ul> <li>\ud835\udc42(\ud835\udc5b+\ud835\udc5a), for the dp array and the dictionary set.</li> </ul> </li> </ul>"},{"location":"dynamic-programming/word-break/#conclusion","title":"Conclusion","text":"<p>This method efficiently ensures all possible segmentations are checked systematically.</p>"},{"location":"in-place/set-matrix-zeroes/","title":"73. Set Matrix Zeroes","text":""},{"location":"in-place/set-matrix-zeroes/#problem-statement","title":"Problem Statement","text":"<p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>'s.\\ You must do it in place.</p>"},{"location":"in-place/set-matrix-zeroes/#approach-in-place","title":"Approach: In-place","text":"<p>We modify the matrix in-place by using the first row and column as markers.</p>"},{"location":"in-place/set-matrix-zeroes/#use-first-row-and-first-column-as-markers","title":"Use First Row and First Column as Markers:","text":"<ul> <li>Traverse the matrix, and if an element is <code>0</code>, mark the corresponding row and column in the first row and first column.</li> </ul>"},{"location":"in-place/set-matrix-zeroes/#set-the-matrix-elements-to-zero","title":"Set the Matrix Elements to Zero:","text":"<ul> <li>Traverse the matrix again, and based on the markers, set the elements in the corresponding rows and columns to <code>0</code>.</li> </ul>"},{"location":"in-place/set-matrix-zeroes/#handle-the-first-row-and-first-column-separately","title":"Handle the First Row and First Column Separately:","text":"<ul> <li>Since they are used as markers, use separate flags to determine if they themselves need to be set to <code>0</code>.</li> </ul>"},{"location":"in-place/set-matrix-zeroes/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\n    public:\n        void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n            int m = matrix.size(), n = matrix[0].size();\n            bool firstRowZero = false, firstColZero = false;\n\n            for (int i = 0; i &lt; m; i++)\n                if (matrix[i][0] == 0) firstColZero = true;\n            for (int j = 0; j &lt; n; j++) \n                if (matrix[0][j] == 0) firstRowZero = true;\n\n            for (int i = 1; i &lt; m; i++) {\n                for (int j = 1; j &lt; n; j++) {\n                    if (matrix[i][j] == 0) {\n                        matrix[i][0] = 0;\n                        matrix[0][j] = 0;\n                    }\n                }\n            }\n\n            for (int i = 1; i &lt; m; i++) {\n                for (int j = 1; j &lt; n; j++) {\n                    if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                        matrix[i][j] = 0;\n                }\n            }\n\n            if (firstRowZero)\n                fill(matrix[0].begin(), matrix[0].end(), 0);\n            if (firstColZero)\n                for (int i = 0; i &lt; m; i++) matrix[i][0] = 0;\n        }\n    };\n</code></pre>"},{"location":"in-place/set-matrix-zeroes/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5a \u00d7 \ud835\udc5b) \u2014 The matrix is traversed multiple times, but the traversal remains linear relative to its size.</p> </li> <li> <p>Space Complexity: \ud835\udc42(1) \u2014 No additional space is used beyond a few extra variables.</p> </li> </ul>"},{"location":"in-place/set-matrix-zeroes/#conclusion","title":"Conclusion","text":"<p>This achieves the desired result using constant space and two passes.</p>"},{"location":"sliding-window/find-all-anagrams/","title":"438. Find All Anagrams in a String","text":""},{"location":"sliding-window/find-all-anagrams/#problem-statement","title":"Problem Statement","text":"<p>Given two strings <code>s</code> and <code>p</code>, return an array of all the start indices of <code>p</code>'s anagrams in <code>s</code>. You may return the answer in any order.</p>"},{"location":"sliding-window/find-all-anagrams/#approach-sliding-window","title":"Approach: Sliding Window","text":"<p>Use a sliding window with frequency counts to track anagrams efficiently.</p>"},{"location":"sliding-window/find-all-anagrams/#frequency-arrays","title":"Frequency Arrays:","text":"<ul> <li> <p><code>count_p</code> stores the character frequencies of <code>p</code>.</p> </li> <li> <p><code>count_window</code> tracks the character frequencies in the current window of <code>s</code>.</p> </li> </ul>"},{"location":"sliding-window/find-all-anagrams/#initialize-the-first-window","title":"Initialize the First Window:","text":"<ul> <li> <p>Process the first <code>p.length()</code> characters of <code>s</code> to initialize <code>count_window</code>.</p> </li> <li> <p>Compare <code>count_window</code> with <code>count_p</code>\u2014if they match, store the starting index (<code>0</code>).</p> </li> </ul>"},{"location":"sliding-window/find-all-anagrams/#sliding-the-window","title":"Sliding the Window:","text":"<ul> <li> <p>For every new character in <code>s</code> (starting from index <code>p.length()</code>), adjust <code>count_window</code>:</p> <ul> <li>Remove the character that is slides out of the window.</li> <li>Add the new character that slides into the window.</li> </ul> </li> <li> <p>After each adjustment, compare <code>count_window</code> and <code>count_p</code>. If they match, store the current starting index.</p> </li> </ul>"},{"location":"sliding-window/find-all-anagrams/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; findAnagrams(string s, string p) {\n        vector&lt;int&gt; result;\n        if (s.length() &lt; p.length()) return result;\n\n        vector&lt;int&gt; count_p(26, 0);\n        vector&lt;int&gt; count_window(26, 0);\n\n        for (int i = 0; i &lt; p.length(); i++) {\n            count_p[p[i] - 'a']++;\n            count_window[s[i] - 'a']++;\n        }\n        if (count_window == count_p) {\n            result.push_back(0);\n            }\n        for (int i = p.length(); i &lt; s.length(); i++) {\n            count_window[s[i - p.length()] - 'a']--;\n\n            count_window[s[i] - 'a']++;\n\n            if (count_window == count_p) {\n                result.push_back(i - p.length() + 1);\n            }\n        }   \n        return result;\n    }\n};\n</code></pre>"},{"location":"sliding-window/find-all-anagrams/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014 Each character is processed once.</p> </li> <li> <p>Space Complexity: \ud835\udc42(1) \u2014 The frequency arrays have a fixed size of 26, meaning constant space is used.</p> </li> </ul>"},{"location":"sliding-window/find-all-anagrams/#conclusion","title":"Conclusion","text":"<p>This impletmentation ensures linear time complexity by avoiding repeated sorting or comparisons.</p>"},{"location":"sliding-window/product-of-array-except-self/","title":"238. Product of Array Except Self","text":""},{"location":"sliding-window/product-of-array-except-self/#problem-statement","title":"Problem Statement","text":"<p>Given an integer array <code>nums</code>, return an array <code>answer</code> such that <code>answer[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p> <p>The product of any prefix or suffix of <code>nums</code> is guaranteed to fit in a 32-bit integer.</p> <p>You must write an algorithm that runs in <code>\ud835\udc42(\ud835\udc5b)</code> time and without using the division operation.</p>"},{"location":"sliding-window/product-of-array-except-self/#approach-sliding-window","title":"Approach: Sliding Window","text":"<p>Compute prefix and suffix products in two passes to build the result without division.</p>"},{"location":"sliding-window/product-of-array-except-self/#left-products-pass","title":"Left Products Pass:","text":"<ul> <li> <p>Initialize left_product to 1.</p> </li> <li> <p>Iterate through the array from left to right.</p> </li> <li> <p>For each index <code>i</code>, set <code>answer[i]</code> to left_product.</p> </li> <li> <p>Update left_product by multiplying it with <code>nums[i]</code>.</p> </li> </ul> <p>This pass fills the answer array with the products of all elements to the left of each index.</p>"},{"location":"sliding-window/product-of-array-except-self/#right-products-pass","title":"Right Products Pass:","text":"<ul> <li> <p>Initialize right_product to 1.</p> </li> <li> <p>Iterate through the array from right to left.</p> </li> <li> <p>For each index <code>i</code>, multiply <code>answer[i]</code> by right_product.</p> </li> <li> <p>Update right_product by multiplying it with <code>nums[i]</code>.</p> </li> </ul> <p>This pass adjusts the answer array to include the products of all elements to the right of each index.</p> <p>By combining these two passes, we achieve the desired result where <code>answer[i]</code> is the product of all elements in nums except <code>nums[i]</code>.</p>"},{"location":"sliding-window/product-of-array-except-self/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\n    public:\n        vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {\n            int length = nums.size();\n            vector&lt;int&gt; answer(length,1);\n\n            int left_product = 1;\n            for (int i = 0; i &lt; length; ++i) {\n                answer[i] = left_product;\n                left_product *= nums[i];\n            }\n\n            int right_product = 1;\n            for (int i = length - 1; i &gt;= 0; --i) {\n                answer[i] *= right_product;\n                right_product *= nums[i];\n            }\n\n            return answer;\n        }\n    };\n</code></pre>"},{"location":"sliding-window/product-of-array-except-self/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014 The algorithm makes two passes over the array, resulting in linear time complexity.</p> </li> <li> <p>Space Complexity: \ud835\udc42(\ud835\udc5b) \u2014 The space complexity is linear due to the output array.</p> </li> </ul>"},{"location":"sliding-window/product-of-array-except-self/#conclusion","title":"Conclusion","text":"<p>This achieves \ud835\udc42(\ud835\udc5b) time and space complexity without using division.</p>"},{"location":"sorting/sort-colors/","title":"75. Sort Colors","text":""},{"location":"sorting/sort-colors/#problem-statement","title":"Problem Statement","text":"<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them in place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p> <p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p> <p>You must solve this problem without using the library's sort function.</p>"},{"location":"sorting/sort-colors/#approach-sorting","title":"Approach: Sorting","text":"<p>Use the Dutch National Flag algorithm with three pointers to sort colors in a single pass.</p>"},{"location":"sorting/sort-colors/#the-algorithm-uses-three-pointers","title":"The algorithm uses three pointers:","text":"<ul> <li> <p>low: Points to the boundary where the next 0 should go.</p> </li> <li> <p>mid: Scans through the array.</p> </li> <li> <p>high: Points to the boundary where the next 2 should go.</p> </li> </ul>"},{"location":"sorting/sort-colors/#we-iterate-through-the-array-with-the-mid-pointer-adjusting-the-positions-of-0s-and-2s-as-follows","title":"We iterate through the array with the mid pointer, adjusting the positions of 0s and 2s as follows:","text":"<ul> <li> <p>If nums[mid] is 0, swap it with the element at low, and increment both low and mid.</p> </li> <li> <p>If nums[mid] is 1, just move the mid pointer forward.</p> </li> <li> <p>If nums[mid] is 2, swap it with the element at high, and decrement high.</p> </li> </ul> <p>This ensures that 0s are moved to the front, 2s are moved to the back, and 1s remain in the middle, effectively sorting the array in a single pass without using any sorting library functions.</p>"},{"location":"sorting/sort-colors/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) {\n        int low = 0, mid = 0, high = nums.size() - 1;\n\n        while (mid &lt;= high) {\n            if (nums[mid] == 0) {\n                swap(nums[low], nums[mid]);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else {  // nums[mid] == 2\n                swap(nums[high], nums[mid]);\n                high--;\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"sorting/sort-colors/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014 The algorithm iterates through the array only once with the mid pointer, making a single pass through the array, where n is the number of elements. Each element is visited at most once, so the time complexity is linear, O(\ud835\udc5b). </p> </li> <li> <p>Space Complexity: \ud835\udc42(1) \u2014 The algorithm sorts the array in place by using only a constant amount of extra space for the three pointers (low, mid, high). No additional data structures (like arrays or lists) are used, so the space complexity is constant, O(1).</p> </li> </ul>"},{"location":"sorting/sort-colors/#conclusion","title":"Conclusion","text":"<p>Efficiently sorts the array in-place with \ud835\udc42(\ud835\udc5b) time and \ud835\udc42(1) space.</p>"},{"location":"stacks/decode-string/","title":"394. Decode String","text":""},{"location":"stacks/decode-string/#problem-statement","title":"Problem Statement","text":"<p>Given an encoded string, return its decoded string.</p> <p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p> <p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p> <p>The test cases are generated so that the length of the output will never exceed <code>10\u2075</code>.</p>"},{"location":"stacks/decode-string/#approach-two-stacks","title":"Approach:  Two Stacks","text":"<p>We use two stacks: - countStack to store repeat counts (<code>k</code>). - resultStack to store intermediate decoded strings.</p>"},{"location":"stacks/decode-string/#digit-handling-0-9","title":"Digit Handling (<code>0-9</code>):","text":"<ul> <li>Build <code>k</code> by processing consecutive digits.</li> </ul>"},{"location":"stacks/decode-string/#opening-bracket","title":"Opening Bracket (<code>[</code>):","text":"<ul> <li>Push <code>k</code> onto <code>countStack</code> and the current string onto <code>resultStack</code>. </li> <li>Reset <code>k</code> and <code>currentResult</code> for the next segment.</li> </ul>"},{"location":"stacks/decode-string/#closing-bracket","title":"Closing Bracket (<code>]</code>):","text":"<ul> <li>Pop <code>k</code> from <code>countStack</code> and the last decoded segment from <code>resultStack</code>. </li> <li>Repeat <code>currentResult</code> <code>k</code> times and append that to the previous result.</li> </ul>"},{"location":"stacks/decode-string/#character-handlinga-z","title":"Character Handling(<code>a-z</code>):","text":"<ul> <li>Append normal characters to <code>currentResult</code>.</li> </ul> <pre><code>class Solution {\npublic:\n    string decodeString(string s) {\n        stack&lt;int&gt; countStack;\n        stack&lt;string&gt; resultStack;\n        string currentResult = \"\";\n        int k = 0;\n\n        for (char c : s) {\n            if (isdigit(c)) {\n                k = k * 10 + (c - '0');\n\n            } else if (c == '[') {\n                countStack.push(k);\n                resultStack.push(currentResult);\n                k = 0;\n                currentResult = \"\";\n\n            } else if (c == ']') {\n                int repeatCount = countStack.top();\n                countStack.pop();\n                string decodedSegment = resultStack.top();\n                resultStack.pop();\n\n                while (repeatCount--) {\n                    decodedSegment += currentResult;\n                }\n                currentResult = decodedSegment;\n\n            } else {\n                currentResult += c;\n            }\n        }\n        return currentResult;\n    }\n};\n</code></pre>"},{"location":"stacks/decode-string/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) </p> <ul> <li>Each character is processed exactly once. </li> <li>Stack operations (<code>push/pop</code>) are \ud835\udc42(1).</li> </ul> </li> <li> <p>Space Complexity: \ud835\udc42(\ud835\udc5b) </p> <ul> <li>Worst-case: deeply nested structures require storing intermediate results in stacks.</li> </ul> </li> </ul>"},{"location":"stacks/decode-string/#conclusion","title":"Conclusion","text":"<p>Uses a stack to decode nested patterns in a structured string format, reconstructing the original message.</p>"},{"location":"stacks/implement-queue-using-stacks/","title":"232. Implement Queue using Stacks","text":""},{"location":"stacks/implement-queue-using-stacks/#problem-statement","title":"Problem Statement","text":"<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p> <p>Implement the <code>MyQueue</code> class:</p> <ul> <li> <p><code>void push(int x)</code> Pushes element x to the back of the queue.</p> </li> <li> <p><code>int pop()</code> Removes the element from the front of the queue and returns it.</p> </li> <li> <p><code>int peek()</code> Returns the element at the front of the queue.</p> </li> <li> <p><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</p> </li> </ul> <p>Notes:</p> <ul> <li> <p>You must use only standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</p> </li> <li> <p>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.</p> </li> </ul>"},{"location":"stacks/implement-queue-using-stacks/#approach-two-stacks","title":"Approach: Two Stacks","text":"<p>The approach uses one stack (<code>inputStack</code>) for pushing new elements and another stack (<code>outputStack</code>) for popping and peeking elements.</p>"},{"location":"stacks/implement-queue-using-stacks/#pushint-x","title":"<code>push(int x)</code>:","text":"<ul> <li>Simply push the element onto the <code>inputStack</code>.</li> </ul>"},{"location":"stacks/implement-queue-using-stacks/#pop","title":"<code>pop()</code>:","text":"<ul> <li> <p>If <code>outputStack</code> is empty, transfer all elements from <code>inputStack</code> to <code>outputStack</code>. This reverses the order of elements, so the top of <code>outputStack</code> is the front of the queue.</p> </li> <li> <p>Pop the top element of <code>outputStack</code>.</p> </li> </ul>"},{"location":"stacks/implement-queue-using-stacks/#peek","title":"<code>peek()</code>:","text":"<ul> <li>Similar to <code>pop()</code>, but instead of removing the element, return the top of <code>outputStack</code>.</li> </ul>"},{"location":"stacks/implement-queue-using-stacks/#empty","title":"<code>empty()</code>:","text":"<ul> <li>The queue is empty only if both stacks are empty.</li> </ul>"},{"location":"stacks/implement-queue-using-stacks/#code-c","title":"Code (C++)","text":"<pre><code>class MyQueue {\n    private:\n        stack&lt;int&gt; inputStack; \n        stack&lt;int&gt; outputStack;\n\n    public:\n        MyQueue() {\n\n        }\n\n        void push(int x) {\n            inputStack.push(x);\n        }\n\n        int pop() {\n            if (outputStack.empty()) {\n\n                while (!inputStack.empty()) {\n                    outputStack.push(inputStack.top());\n                    inputStack.pop();\n                }\n            }\n            int front = outputStack.top();\n            outputStack.pop();\n            return front;\n        }\n\n        int peek() {\n            if (outputStack.empty()) {\n\n                while (!inputStack.empty()) {\n                    outputStack.push(inputStack.top());\n                    inputStack.pop();\n                }\n            }\n            return outputStack.top();\n        }\n\n        bool empty() {\n            return inputStack.empty() &amp;&amp; outputStack.empty();\n    }\n};\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;peek();\n * bool param_4 = obj-&gt;empty();\n */\n</code></pre>"},{"location":"stacks/implement-queue-using-stacks/#complexity","title":"Complexity","text":"<ul> <li>Time Complexity:</li> <li> <p>Push (\ud835\udc42(1)) \u2014 Always inserts elements into <code>inputStack</code>.</p> </li> <li> <p>Pop (Amortized \ud835\udc42(1)) \u2014 Moves elements from <code>inputStack</code> to <code>outputStack</code> when <code>outputStack</code> is empty, then pops.</p> </li> <li> <p>Peek (Amortized \ud835\udc42(1)) \u2014 Similar to <code>pop()</code>, but only returns the front element without removing that element.</p> </li> <li> <p>Empty (\ud835\udc42(1)) \u2014 Checks if both stacks are empty.  </p> </li> <li> <p>Space Complexity: \ud835\udc42(\ud835\udc5b) \u2014 Where <code>n</code> is the number of elements in the queue (storage across the two stacks).</p> </li> </ul>"},{"location":"stacks/implement-queue-using-stacks/#conclusion","title":"Conclusion","text":"<p>This implementation efficiently simulates a FIFO queue using two stacks and supports all the required operations.</p>"},{"location":"string-manipulation/string-to-integer-atoi/","title":"8. String to Integer (atoi)","text":""},{"location":"string-manipulation/string-to-integer-atoi/#problem-statement","title":"Problem Statement","text":"<p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer.</p> <p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p> <ol> <li> <p>Whitespace: Ignore any leading whitespace (<code>\" \"</code>).</p> </li> <li> <p>Signedness: Determine the sign by checking if the next character is <code>'-'</code> or <code>'+'</code>, assuming positivity if neither present.</p> </li> <li> <p>Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.</p> </li> <li> <p>Rounding: If the integer is out of the 32-bit signed integer range <code>[-2</code><sup><code>31</code></sup>, <code>2</code><code>31</code><code>- 1]</code>, then round the integer to remain in the range. Specifically, integers less than <code>-2</code><code>31</code> should be rounded to -231, and integers greater than <code>2</code><code>31</code><code>- 1</code> should be rounded to <code>2</code><code>31</code><code>- 1</code>. Return the integer as the final result.</p> </li> </ol>"},{"location":"string-manipulation/string-to-integer-atoi/#approach-string-manipulation","title":"Approach: String Manipulation","text":"<p>The <code>myAtoi()</code> function converts a string to an integer following the Finite State Machine (FSM) pattern.</p>"},{"location":"string-manipulation/string-to-integer-atoi/#the-process-consists-of-five-distinct-states","title":"The process consists of five distinct states:","text":"<ol> <li> <p>Ignore Leading Whitespaces</p> </li> <li> <p>Skip all leading spaces using:</p> </li> </ol> <pre><code>while (i &lt; n &amp;&amp; s[i] == ' ') {\n    ++i;\n}\n</code></pre> <ul> <li> <p>Moves to the next state when a non-space character is found.</p> </li> <li> <p>Determine the Sign</p> </li> <li> <p>If <code>s[i] == '+'</code>, set <code>sign = 1</code>.</p> </li> <li> <p>If <code>s[i] == '-'</code>, set <code>sign = -1</code>.</p> </li> <li> <p>Move to the next character.</p> </li> <li> <p>Convert Digits to an Integer</p> </li> <li> <p>If <code>isdigit(s[i])</code>, accumulate the number:</p> </li> </ul> <pre><code>result = result * 10 + (s[i] - '0');\n</code></pre> <ul> <li> <p>If a non-digit is found, stop processing.</p> </li> <li> <p>Handle Overflow</p> </li> <li> <p>Since <code>result</code> is of type <code>long long</code>, we check:</p> </li> </ul> <pre><code>if (result * sign &gt; INT_MAX) return INT_MAX;\nif (result * sign &lt; INT_MIN) return INT_MIN;\n</code></pre> <ul> <li> <p>This clamps the number within the 32-bit integer range.</p> </li> <li> <p>Return the Final Value</p> </li> <li> <p>Multiply <code>result</code> by <code>sign</code> and return the integer.</p> </li> </ul>"},{"location":"string-manipulation/string-to-integer-atoi/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\n    public:\n        int myAtoi(string s) {\n            int i = 0, n = s.length();\n\n            while (i &lt; n &amp;&amp; s[i] == ' ') {\n                ++i;\n            }\n\n            int sign = 1;\n            if (i &lt; n &amp;&amp; (s[i] == '-' || s[i] == '+')) {\n                sign = (s[i] == '-') ? -1 : 1;\n                ++i;\n            }\n\n            long long result = 0;\n            while (i &lt; n &amp;&amp; isdigit(s[i])) {\n                result = result * 10 + (s[i] - '0');\n\n                if (result * sign &gt; INT_MAX) return INT_MAX;\n                if (result * sign &lt; INT_MIN) return INT_MIN;\n                ++i;\n            }\n            return result * sign;\n        }\n    };\n</code></pre>"},{"location":"string-manipulation/string-to-integer-atoi/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014 The function processes each character in the string at most once, and the while loops iterate through the string linearly, where n is the length of the input string.</p> </li> <li> <p>Space Complexity: \ud835\udc42(1) \u2014 The function does not use extra space that grows with the input size, only using a few integer variables.</p> </li> </ul>"},{"location":"string-manipulation/string-to-integer-atoi/#conclusion","title":"Conclusion","text":"<p>This method accurately parses and clamps the string into a valid 32-bit integer using efficient linear processing.</p>"},{"location":"trees/binary-tree-right-side-view/","title":"199. Binary Tree Right Side View","text":""},{"location":"trees/binary-tree-right-side-view/#problem-statement","title":"Problem Statement","text":"<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>"},{"location":"trees/binary-tree-right-side-view/#approach-using-breadth-first-search","title":"Approach: Using Breadth First Search","text":"<p>We can perform a level-order traversal (or Breadth-First Search) on the binary tree. At each level, the rightmost node is the one visible from the right side view.</p>"},{"location":"trees/binary-tree-right-side-view/#queue-and-level-processing","title":"Queue and Level Processing:","text":"<ul> <li> <p>A queue is used to traverse nodes level by level.</p> </li> <li> <p>At each level, the last node in the queue is the rightmost node visible from that level.</p> </li> </ul>"},{"location":"trees/binary-tree-right-side-view/#edge-cases","title":"Edge Cases:","text":"<ul> <li>If the tree is empty (<code>root == nullptr</code>), return an empty vector.</li> </ul>"},{"location":"trees/binary-tree-right-side-view/#final-result","title":"Final Result:","text":"<ul> <li>The <code>result</code> vector contains the values of the rightmost nodes of all levels, ordered from top to bottom.  </li> </ul>"},{"location":"trees/binary-tree-right-side-view/#code-c","title":"Code (C++)","text":"<pre><code>/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;int&gt; rightSideView(TreeNode* root) {\n        vector&lt;int&gt; result; \n        if (!root) return result; \n\n        queue&lt;TreeNode*&gt; q; \n        q.push(root); \n\n        while (!q.empty()) {\n            int levelSize = q.size();\n            TreeNode* rightmost = nullptr;\n\n            for (int i = 0; i &lt; levelSize; i++) {\n                TreeNode* currentNode = q.front();\n                q.pop();\n\n                rightmost = currentNode;\n\n                if (currentNode-&gt;left) q.push(currentNode-&gt;left);\n                if (currentNode-&gt;right) q.push(currentNode-&gt;right);                    \n            }\n\n            result.push_back(rightmost-&gt;val);                \n        }\n\n        return result;\n    }\n};\n</code></pre>"},{"location":"trees/binary-tree-right-side-view/#complexity","title":"Complexity","text":"<ul> <li> <p>Time: \ud835\udc42(\ud835\udc5b), where \ud835\udc5b is the number of nodes in the tree. Each node is visited once.</p> </li> <li> <p>Space: \ud835\udc42(\ud835\udc64), where \ud835\udc64 is the maximum width of the tree (the number of nodes at the largest level).</p> </li> </ul>"},{"location":"trees/binary-tree-right-side-view/#conclusion","title":"Conclusion","text":"<p>This implementation efficiently uses BFS to gather the rightmost node at each level, producing the desired view with linear time and space complexity.</p>"},{"location":"trees/course-schedule-ii/","title":"210. Course Schedule II","text":""},{"location":"trees/course-schedule-ii/#problem-statement","title":"Problem Statement","text":"<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>.  You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a</code><sub><code>i</code></sub><code>, b</code><sub><code>i</code></sub><code>]</code> indicates that you must take course <code>b</code><sub><code>i</code></sub> first if you want to take course <code>a</code><sub><code>i</code></sub>. - For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take  course <code>1</code>.</p> <p>Return the ordering of courses you should take to finish all courses. If there are many valid  answers, return any of them. If it is impossible to finish all courses, return an empty array.</p>"},{"location":"trees/course-schedule-ii/#approach-using-breadth-first-search","title":"Approach: Using Breadth First Search","text":"<p>To determine the order in which courses can be taken, we can use BFS approach for topological sorting. This problem is essentially a graph problem where courses are nodes and prerequisites are directed edges.</p>"},{"location":"trees/course-schedule-ii/#graph-construction","title":"Graph Construction:","text":"<ul> <li>Represent courses as nodes and prerequisites as directed edges in the graph.</li> </ul>"},{"location":"trees/course-schedule-ii/#bfs-for-topological-sort","title":"BFS for Topological Sort:","text":"<ul> <li> <p>Start with courses that have no prerequisites (in-degree <code>0</code>).</p> </li> <li> <p>Process these courses, adding their neighbors to the queue when their prerequisites are fulfilled (in-degree becomes <code>0</code>).</p> </li> </ul>"},{"location":"trees/course-schedule-ii/#cycle-detection","title":"Cycle Detection:","text":"<ul> <li>If not all courses are processed, it indicates a cycle in the graph, making it impossible to complete all courses.</li> </ul>"},{"location":"trees/course-schedule-ii/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; adjList(numCourses);\n        vector&lt;int&gt; inDegree(numCourses, 0);\n\n        for (auto&amp; prereq : prerequisites) {\n            int course = prereq[0];\n            int prerequisite = prereq[1];\n            adjList[prerequisite].push_back(course);\n            inDegree[course]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        vector&lt;int&gt; result;\n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            result.push_back(current);\n\n            for (int neighbor : adjList[current]) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        if (result.size() == numCourses) {\n            return result;\n        } else {\n            return {};\n        }\n    }\n};\n</code></pre>"},{"location":"trees/course-schedule-ii/#complexity","title":"Complexity","text":"<p>Time: \ud835\udc42(\ud835\udc49 + \ud835\udc38)  - Where \ud835\udc49 is the number of courses and \ud835\udc38 is the number of prerequisites.  - We build the graph in \ud835\udc42(\ud835\udc38) and travere the graph in \ud835\udc42(\ud835\udc49 + \ud835\udc38).</p> <p>Space: \ud835\udc42(\ud835\udc49 + \ud835\udc38)  - For the adjacency list and the in-degree tracking.</p>"},{"location":"trees/course-schedule-ii/#conclusion","title":"Conclusion","text":"<p>This approach efficiently computes the course order or detects if that's impossible to complete all courses due to cyclic dependencies.</p>"},{"location":"trees/lowest-common-ancestor/","title":"236. Lowest Common Ancestor of a Binary Tree","text":""},{"location":"trees/lowest-common-ancestor/#problem-statement","title":"Problem Statement","text":"<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. You are given references to the root of a binary tree and two nodes <code>p</code> and <code>q</code>. Return the LCA of nodes <code>p</code> and <code>q</code>.</p>"},{"location":"trees/lowest-common-ancestor/#approach-tree-dfs","title":"Approach: Tree DFS","text":"<p>We use Depth-First Search (DFS) to traverse the tree recursively.</p>"},{"location":"trees/lowest-common-ancestor/#base-case","title":"Base Case:","text":"<ul> <li>If the current node is <code>nullptr</code>, we\u2019ve reached a leaf.</li> <li>If the current node is equal to <code>p</code> or <code>q</code>, return it.</li> </ul>"},{"location":"trees/lowest-common-ancestor/#recursive-search","title":"Recursive Search:","text":"<ul> <li>Recursively search the left and right subtrees.</li> </ul>"},{"location":"trees/lowest-common-ancestor/#combine-results","title":"Combine Results:","text":"<ul> <li>If both left and right return non-null, current node is the LCA.</li> <li>If one side is null, return the non-null child.</li> </ul>"},{"location":"trees/lowest-common-ancestor/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n</code></pre>"},{"location":"trees/lowest-common-ancestor/#complexity","title":"Complexity","text":"<ul> <li> <p>Time: \ud835\udc42(\ud835\udc5b), where \ud835\udc5b is the number of nodes in the binary tree.</p> </li> <li> <p>Space: \ud835\udc42(\u210e), where \u210e is the height of the binary tree (due to the recursion stack).</p> </li> </ul>"},{"location":"trees/lowest-common-ancestor/#conclusion","title":"Conclusion","text":"<p>This approach efficiently locates the LCA by leveraging recursive post-order traversal.</p>"},{"location":"trees/rotting-oranges/","title":"994. Rotting Oranges","text":""},{"location":"trees/rotting-oranges/#problem-statement","title":"Problem Statement","text":"<p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values: - <code>0</code> representing an empty cell, - <code>1</code> representing a fresh orange, or - <code>2</code> representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return <code>-1</code>.</p>"},{"location":"trees/rotting-oranges/#approach-using-breadth-first-search","title":"Approach: Using Breadth First Search","text":"<p>We can use Breadth-First Search (BFS) to simulate the rotting process of the oranges.</p>"},{"location":"trees/rotting-oranges/#bfs-traversal","title":"BFS Traversal:","text":"<ul> <li>BFS allows rotting to propagate minute by minute, in all four directions, matching the problem\u2019s requirement.</li> </ul>"},{"location":"trees/rotting-oranges/#tracking-time","title":"Tracking Time:","text":"<ul> <li>Each level of BFS represents one minute passing. We increment <code>minutes</code> after processing each level.</li> </ul>"},{"location":"trees/rotting-oranges/#edge-cases","title":"Edge Cases:","text":"<ul> <li> <p>If there are no fresh oranges from the start, return <code>0</code>.</p> </li> <li> <p>If some fresh oranges cannot be reached, return <code>-1</code>.</p> </li> </ul>"},{"location":"trees/rotting-oranges/#code-c","title":"Code (C++)","text":"<pre><code>class Solution {\npublic:\n    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        int freshCount = 0;\n        int minutes = 0;\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 2) {\n                    q.push({i, j}); \n                } else if (grid[i][j] == 1) {\n                    freshCount++;\n                }\n            }\n        }\n\n        vector&lt;pair&lt;int, int&gt;&gt; directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        while (!q.empty() &amp;&amp; freshCount &gt; 0) {\n            int levelSize = q.size();\n            for (int i = 0; i &lt; levelSize; i++) {\n                auto [x, y] = q.front();\n                q.pop();\n\n                for (auto [dx, dy] : directions) {\n                    int nx = x + dx;\n                    int ny = y + dy;\n\n                    if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == 1) {\n                        grid[nx][ny] = 2;\n                        q.push({nx, ny});\n                        freshCount--;\n                    }\n                }\n            }\n            minutes++;\n        }\n\n        return freshCount == 0 ? minutes : -1;\n    }\n};\n</code></pre>"},{"location":"trees/rotting-oranges/#complexity","title":"Complexity","text":"<ul> <li> <p>Time: \ud835\udc42(\ud835\udc5a \u00d7 \ud835\udc5b), every cell is visited at most once.</p> </li> <li> <p>Space: \ud835\udc42(\ud835\udc5a \u00d7 \ud835\udc5b), space used by the queue and auxiliary structures like the <code>directions</code> vector.</p> </li> </ul>"},{"location":"trees/rotting-oranges/#conclusion","title":"Conclusion","text":"<p>This BFS-based solution effectively simulates the rotting process and determines the minimum time required or detects when it\u2019s impossible to rot all oranges.</p>"},{"location":"two-pointers/palindrome-linked-list/","title":"234. Palindrome Linked List","text":""},{"location":"two-pointers/palindrome-linked-list/#problem-statement","title":"Problem Statement","text":"<p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome or <code>false</code> otherwise.</p>"},{"location":"two-pointers/palindrome-linked-list/#approach-two-pointers","title":"Approach:  Two Pointers","text":"<p>Use two pointers to find the middle of the list, reverse the second half, and compare both halves for equality.</p>"},{"location":"two-pointers/palindrome-linked-list/#finding-the-middle","title":"Finding the Middle:","text":"<ul> <li>Use two pointers (slow and fast) to identify the middle of the linked list. The slow pointer moves one step at a time, while fast moves two steps. When fast reaches the end, slow will be at the middle.</li> </ul>"},{"location":"two-pointers/palindrome-linked-list/#reversing-the-second-half","title":"Reversing the Second Half:","text":"<ul> <li>Reverse the portion of the linked list starting from the middle. This allows for an in-place comparison of values.</li> </ul>"},{"location":"two-pointers/palindrome-linked-list/#comparing-both-halves","title":"Comparing Both Halves:","text":"<ul> <li>Compare the first half of the linked list to the reversed second half. If all values match, the list is a palindrome.</li> </ul> <p>/\\  \u00a0* Definition for singly-linked list.\\  \u00a0* struct ListNode {\\  \u00a0*     int val;\\  \u00a0*     ListNode next;\\  \u00a0*     ListNode( ) : val(0), next(nullptr) { }\\  \u00a0*     ListNode(int x) : val(x), next(nullptr) { }\\  \u00a0*     ListNode(int x, ListNode next) : val(x), next(next) { }\\ \u00a0* };\\ \u00a0*/</p> <pre><code>class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if (!head || !head-&gt;next) return true;\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n        }\n\n        ListNode* prev = nullptr;\n        ListNode* current = slow;\n        while (current) {\n            ListNode* temp = current-&gt;next;\n            current-&gt;next = prev;\n            prev = current;\n            current = temp;\n        }\n\n        ListNode* left = head;\n        ListNode* right = prev;\n        while (right) {\n            if (left-&gt;val != right-&gt;val) {\n                return false;\n            }\n            left = left-&gt;next;\n            right = right-&gt;next;                    \n        }            \n        return true;\n    }\n};\n</code></pre>"},{"location":"two-pointers/palindrome-linked-list/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014      The list is traversed multiple times:</p> <ul> <li> <p>To find the middle of the list.</p> </li> <li> <p>To reverse the second half.</p> </li> <li> <p>To compare the two halves.</p> </li> </ul> </li> <li> <p>Space Complexity: \ud835\udc42(1) \u2014 No additional space is used other than pointers.</p> </li> </ul>"},{"location":"two-pointers/palindrome-linked-list/#conclusion","title":"Conclusion","text":"<p>This in-place solution checks for palindrome efficiently with linear time and constant space.</p>"},{"location":"two-pointers/reorder-list/","title":"143. Reorder List","text":""},{"location":"two-pointers/reorder-list/#problem-statement","title":"Problem Statement","text":"<p>You are given the head of a singly linked-list. The list can be represented as:</p> <p>L<sub>0</sub> \u2192 L<sub>1</sub> \u2192 \u2026 \u2192 L<sub>n</sub> - <sub>1</sub> \u2192 L<sub>n</sub> Reorder the list to be on the following form:</p> <p>L<sub>0</sub> \u2192 L<sub>n</sub> \u2192 L<sub>1</sub> \u2192 L<sub>n</sub> - <sub>1</sub> \u2192 L<sub>2</sub> \u2192 L<sub>n</sub> - <sub>2</sub> \u2192 \u2026 You may not modify the values in the list's nodes. Only nodes themselves may be changed.</p>"},{"location":"two-pointers/reorder-list/#approach-two-pointers","title":"Approach:  Two Pointers","text":"<p>Use slow and fast pointers to find the middle, reverse the second half, then merge both halves alternately.</p>"},{"location":"two-pointers/reorder-list/#finding-the-middle","title":"Finding the Middle:","text":"<ul> <li>Use a slow pointer that moves one step at a time and a fast pointer that moves two steps at a time. When the fast pointer reaches the end, the slow pointer will be at the middle.</li> </ul>"},{"location":"two-pointers/reorder-list/#reversing-the-second-half","title":"Reversing the Second Half:","text":"<ul> <li>Starting from the middle, reverse the pointers in the second half of the list using standard reverse-linked-list logic.</li> </ul>"},{"location":"two-pointers/reorder-list/#merging","title":"Merging:","text":"<ul> <li>Alternate nodes from the first and second halves. Stop when the second list is exhausted.</li> </ul> <p>/\\  \u00a0* Definition for singly-linked list.\\  \u00a0* struct ListNode {\\  \u00a0*     int val;\\  \u00a0*     ListNode next;\\  \u00a0*     ListNode() : val(0), next(nullptr) {}\\  \u00a0*     ListNode(int x) : val(x), next(nullptr) {}\\  \u00a0*     ListNode(int x, ListNode next) : val(x), next(next) {}\\ \u00a0* };\\ \u00a0*/</p> <pre><code>class Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if (!head || !head-&gt;next || !head-&gt;next-&gt;next) {\n            return;\n        }\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n        }\n\n        ListNode* prev = nullptr;\n        ListNode* current = slow-&gt;next;\n        slow-&gt;next = nullptr;\n        while (current) {\n            ListNode* temp = current-&gt;next;\n            current-&gt;next = prev;\n            prev = current;\n            current = temp;\n        }\n\n        ListNode* first = head;\n        ListNode* second = prev;\n        while (second) {\n            ListNode* temp1 = first-&gt;next;\n            ListNode* temp2 = second-&gt;next;\n\n            first-&gt;next = second;\n            second-&gt;next = temp1;\n\n            first = temp1;\n            second = temp2;\n        }            \n    }\n};\n</code></pre>"},{"location":"two-pointers/reorder-list/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014 Where n is the number of nodes in the list. Each step (finding the middle, reversing, and merging) takes linear time.</p> </li> <li> <p>Space Complexity: \ud835\udc42(1) \u2014 No additional space is used other than pointers.</p> </li> </ul>"},{"location":"two-pointers/reorder-list/#conclusion","title":"Conclusion","text":"<p>This method reorders the list in-place with linear time and constant extra space.</p>"},{"location":"two-pointers/reverse-words-in-string/","title":"151. Reverse Words in a String","text":""},{"location":"two-pointers/reverse-words-in-string/#problem-statement","title":"Problem Statement","text":"<p>Given an input string <code>s</code>, reverse the order of the words.</p> <p>A word is defined as a sequence of non-space characters. The words in <code>s</code> will be separated by at least one space.</p> <p>Return a string of the words in reverse order concatenated by a single space.</p> <p>Note that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>"},{"location":"two-pointers/reverse-words-in-string/#approach-two-pointers","title":"Approach:  Two Pointers","text":"<p>Split the string by spaces, filter out empty strings, reverse the list, and join with a single space.</p>"},{"location":"two-pointers/reverse-words-in-string/#trimming-spaces","title":"Trimming Spaces:","text":"<ul> <li>Remove leading and trailing spaces by finding the first and last non-space characters.</li> </ul>"},{"location":"two-pointers/reverse-words-in-string/#splitting-words","title":"Splitting Words:","text":"<ul> <li>Use a <code>stringstream</code> to extract words, automatically discarding extra spaces between them.</li> </ul>"},{"location":"two-pointers/reverse-words-in-string/#reversing-order","title":"Reversing Order:","text":"<ul> <li>Store the words in a <code>vector&lt;string&gt;</code> and use <code>reverse()</code> to rearrange them.</li> </ul>"},{"location":"two-pointers/reverse-words-in-string/#joining-words","title":"Joining Words:","text":"<ul> <li>Combines the reversed words back into a single string with only one space between them.</li> </ul> <pre><code>class Solution {\n    public:\n        string reverseWords(string s) {\n            int left = 0, right = s.size() - 1;\n            while (left &lt;= right &amp;&amp; s[left] == ' ') left++;\n            while (right &gt;= left &amp;&amp; s[right] == ' ') right--;\n            s = s.substr(left, right - left + 1);\n\n            stringstream ss(s);\n            string word;\n            vector&lt;string&gt; words;\n            while (ss &gt;&gt; word) {\n                words.push_back(word);\n            }\n\n            reverse(words.begin(), words.end());\n\n            string result;\n            for (int i = 0; i &lt; words.size(); ++i) {\n                if (i &gt; 0) result += \" \";\n                result += words[i];\n            }\n            return result;\n        }\n    };\n</code></pre>"},{"location":"two-pointers/reverse-words-in-string/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014 We perform a few linear scans over <code>s</code> for trimming, splitting, reversing, and joining.</p> </li> <li> <p>Space Complexity: \ud835\udc42(\ud835\udc5b) \u2014 A <code>vector&lt;string&gt;</code> stores words, and the final output string requires extra space.</p> </li> </ul>"},{"location":"two-pointers/reverse-words-in-string/#conclusion","title":"Conclusion","text":"<p>This approach efficiently reverses word order while trimming extra spaces.</p>"},{"location":"two-pointers/two-sum-ii/","title":"167. Two Sum II - Input Array Is Sorted","text":""},{"location":"two-pointers/two-sum-ii/#problem-statement","title":"Problem Statement","text":"<p>Given a 1-indexed array of integers <code>numbers</code> that is already sorted in non-decreasing order, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index1]</code> and <code>numbers[index2]</code> where <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>.</p> <p>Return the indices of the two numbers, <code>index</code><sub><code>1</code></sub> and <code>index</code><sub><code>2</code></sub>, added by one as an integer array <code>[index</code><sub><code>1</code></sub>, <code>index</code><sub><code>2</code></sub><code>]</code> of length 2.</p> <p>The tests are generated such that there is exactly one solution. You may not use the same element twice.</p> <p>Your solution must use only constant extra space.</p>"},{"location":"two-pointers/two-sum-ii/#approach-two-pointers","title":"Approach:  Two Pointers","text":"<p>We use two pointers, left and right, to scan the array from both ends. </p> <ul> <li> <p>If the sum of the elements at these pointers matches the target, we return their 1-indexed positions. </p> </li> <li> <p>If the sum is less than the target, we move the left pointer to the right to increase the sum. </p> </li> <li> <p>If the sum is greater than the target, we move the right pointer to the left to decrease the sum.</p> </li> </ul> <pre><code>class Solution {\n    public:\n        vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {\n            int left = 0, right = numbers.size() - 1;\n\n            while (left &lt; right) {\n                int current_sum = numbers[left] + numbers[right];\n\n                if (current_sum == target) {\n                    return {left + 1, right + 1};\n                } else if (current_sum &lt; target) {\n                    left++;\n                } else {\n                    right--;\n                }                \n            }\n            return {};\n        }\n    };\n</code></pre>"},{"location":"two-pointers/two-sum-ii/#complexity","title":"Complexity","text":"<ul> <li> <p>Time Complexity: \ud835\udc42(\ud835\udc5b) \u2014 In the worst case, we traverse the array once, checking each element with two pointers. </p> </li> <li> <p>Space Complexity: \ud835\udc42(1) \u2014 We are using only a constant amount of extra space (the two pointers), which means the space complexity is constant, or \ud835\udc42(1). </p> </li> </ul>"},{"location":"two-pointers/two-sum-ii/#conclusion","title":"Conclusion","text":"<p>This implementation ensures that we find the correct pair of indices using only constant extra space.</p>"}]}